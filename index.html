<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>LuxeNails Studio</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>Nail</text></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    body { background: #0a0a0a; overflow: hidden; font-family: 'Helvetica Neue', Arial, sans-serif; color: white; }
    #video, #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    #video { z-index: 1; display: none; } #canvas { z-index: 2; display: none; }

    /* === ЛЮКСОВИЙ UI — ОПТИМІЗОВАНО ПІД МОБІЛЬНІ === */
    .btn {
      position: fixed; height: 48px; min-width: 48px; border-radius: 24px;
      background: rgba(20,20,20,0.9); backdrop-filter: blur(25px);
      border: 1.5px solid rgba(212,175,55,0.4); color: #d4af37;
      font-size: 13px; font-weight: 600; display: flex; align-items: center; justify-content: center;
      cursor: pointer; z-index: 100; transition: all 0.3s ease; padding: 0 16px; gap: 6px;
    }
    .btn:hover { transform: scale(1.06); border-color: #d4af37; }
    #uploadBtn { top: 18px; left: 18px; }
    #shapeBtn { top: 18px; right: 18px; }
    #langBtn { top: 18px; left: 50%; transform: translateX(-50%); }

    #modeToggle {
      position: fixed; top: 18px; left: 50%; transform: translateX(-50%); z-index: 100;
      background: rgba(20,20,20,0.9); backdrop-filter: blur(25px); padding: 8px; border-radius: 24px;
      border: 1px solid rgba(212,175,55,0.25); display: flex; gap: 8px;
    }
    .mode { width: 36px; height: 36px; border-radius: 50%; background: rgba(40,40,40,0.8); font-size: 13px; display: flex; align-items: center; justify-content: center; cursor: pointer; }
    .mode.active { background: #d4af37; color: #0a0a0a; transform: scale(1.08); }

    #colorPicker, #shapePicker {
      position: fixed; bottom: 18px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100;
      background: rgba(20,20,20,0.95); backdrop-filter: blur(30px); padding: 16px 20px; border-radius: 28px;
      border: 1px solid rgba(212,175,55,0.2); max-width: 92vw; overflow-x: auto; scrollbar-width: none;
    }
    #colorPicker::-webkit-scrollbar, #shapePicker::-webkit-scrollbar { display: none; }
    #shapePicker { bottom: 100px; display: none; }

    .color { width: 44px; height: 44px; border-radius: 14px; cursor: pointer; border: 2px solid transparent; transition: all 0.25s; }
    .color:hover { transform: scale(1.1); }
    .color.selected { border-color: #d4af37; box-shadow: 0 0 0 2px #d4af37; transform: scale(1.15); }

    .shape { width: 60px; height: 38px; border-radius: 19px; background: #1a1a1a; border: 2px solid rgba(255,255,255,0.15); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #d4af37; transition: all 0.3s; }
    .shape:hover { transform: scale(1.05); border-color: rgba(212,175,55,0.5); }
    .shape.selected { border-color: #d4af37; background: rgba(212,175,55,0.15); transform: scale(1.08); }

    #uploadModal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15,15,15,0.98); backdrop-filter: blur(35px);
      padding: 28px; border-radius: 24px; border: 1.5px solid rgba(212,175,55,0.3); z-index: 1000; display: none; text-align: center; width: 90%; max-width: 380px;
    }
    #uploadModal.show { display: block; }
    #imageUpload { margin: 18px 0; padding: 14px; border: 2px dashed rgba(212,175,55,0.4); border-radius: 16px; background: rgba(35,35,35,0.7); color: white; width: 100%; cursor: pointer; }
    .modal-btn { padding: 12px 24px; margin: 8px; border: none; border-radius: 18px; font-weight: 600; cursor: pointer; }
    #saveDesign { background: linear-gradient(135deg, #d4af37, #b8941f); color: #0a0a0a; }
    #closeModal { background: rgba(40,40,40,0.9); color: #d4af37; border: 1.5px solid rgba(212,175,55,0.4); }

    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a0a; display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 1000; color: #d4af37; font-size: 24px; text-align: center; padding: 30px; gap: 20px;
    }
    .loader { width: 60px; height: 60px; border: 4px solid rgba(212,175,55,0.3); border-top: 4px solid #d4af37; border-radius: 50%; animation: spin 1.2s linear infinite; }

    .indicator {
      position: fixed; left: 50%; transform: translateX(-50%); background: rgba(20,20,20,0.95); color: #d4af37;
      padding: 12px 20px; border-radius: 20px; display: none; align-items: center; gap: 10px; z-index: 99; font-size: 14px;
      border: 1.5px solid rgba(212,175,55,0.3); backdrop-filter: blur(25px); top: 140px;
    }
    .indicator.show { display: flex; }

    @keyframes spin { to { transform: rotate(360deg); } }

    @media (max-width: 480px) {
      .btn { height: 44px; font-size: 12px; padding: 0 14px; }
      .color, .shape { width: 40px; height: 40px; }
      #colorPicker, #shapePicker { padding: 12px 16px; gap: 10px; }
      .mode { width: 32px; height: 32px; font-size: 11px; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div id="title">LuxeNails Studio</div>
    <p id="subtitle">Show your hand to the camera</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <button id="uploadBtn" class="btn">Upload</button>
  <button id="shapeBtn" class="btn">Shape</button>
  <button id="langBtn" class="btn">UA</button>

  <div id="modeToggle">
    <div class="mode active" id="allMode">A</div>
    <div class="mode" id="oneMode">1</div>
  </div>

  <div id="shapePicker"></div>
  <div id="colorPicker"></div>

  <div id="uploadModal">
    <h3 id="modalTitle">Upload Design</h3>
    <p id="modalDesc" style="margin:12px 0; color:#ccc; font-size:13px;">PNG with transparent background</p>
    <input type="file" id="imageUpload" accept="image/*">
    <div style="margin-top:20px;">
      <button id="saveDesign" class="modal-btn">Save</button>
      <button id="closeModal" class="modal-btn">Cancel</button>
    </div>
  </div>

  <div id="handIndicator" class="indicator">
    <span>Hand</span>
    <span id="handText">Show your hand</span>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.158.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    const CONFIG = {
      SMOOTHING_FACTOR: 0.75, HAND_NOT_DETECTED_THRESHOLD: 12,
      NAIL_SCALE_FACTORS: { thumb: 0.42, index: 0.53, middle: 0.55, ring: 0.53, pinky: 0.41 },
      NAIL_ASPECT_RATIOS: { thumb: 0.78, index: 0.72, middle: 0.70, ring: 0.74, pinky: 0.80 },
      NAIL_OFFSETS: { thumb: { x: -0.015, y: -0.025 }, index: { x: 0, y: -0.022 }, middle: { x: 0, y: -0.028 }, ring: { x: 0, y: -0.022 }, pinky: { x: 0.006, y: -0.018 } },
      MIN_SIZE: 28, MAX_SIZE: 92, WRIST_REF: 0.1, SCALE_SENS: 1.9, MAX_SCALE: 2.1, MIN_SCALE: 0.55
    };

    const FINGER_INDICES = { thumb: { tip: 4, mcp: 2 }, index: { tip: 8, mcp: 5 }, middle: { tip: 12, mcp: 9 }, ring: { tip: 16, mcp: 13 }, pinky: { tip: 20, mcp: 17 } };
    const FINGER_KEYS = Object.keys(FINGER_INDICES);

    const SHAPES = [
      { id: 'oval', name: 'Oval', icon: 'Oval' },
      { id: 'almond', name: 'Almond', icon: 'Almond' },
      { id: 'squoval', name: 'Squoval', icon: 'Squoval' },
      { id: 'coffin', name: 'Coffin', icon: 'Coffin' },
      { id: 'stiletto', name: 'Stiletto', icon: 'Stiletto' }
    ];

    const COLORS = ['#d4af37', '#ff6b6b', '#ff9ed8', '#6ab04c', '#4a90e2', '#9b59b6', '#e67e22', '#2ecc71', '#f1c40f', '#34495e'];

    const TEXT = {
      en: { title: "LuxeNails Studio", subtitle: "Show your hand", modalTitle: "Upload Design", modalDesc: "PNG with transparent background", handText: "Show your hand", save: "Save", cancel: "Cancel" },
      ua: { title: "LuxeNails Студія", subtitle: "Покажіть руку", modalTitle: "Завантажити", modalDesc: "PNG з прозорим фоном", handText: "Покажіть руку", save: "Зберегти", cancel: "Скасувати" }
    };

    const state = { lang: 'en', currentColor: COLORS[0], currentShape: 'oval', isAll: true, selectedFinger: -1, lastLandmarks: null, smoothed: null, handNotDetected: 0, handSize: 1.0, showShape: false };
    const el = {
      video: document.getElementById("video"), canvas: document.getElementById("canvas"), loading: document.getElementById("loading"),
      uploadBtn: document.getElementById("uploadBtn"), shapeBtn: document.getElementById("shapeBtn"), langBtn: document.getElementById("langBtn"),
      allMode: document.getElementById("allMode"), oneMode: document.getElementById("oneMode"),
      colorPicker: document.getElementById("colorPicker"), shapePicker: document.getElementById("shapePicker"),
      uploadModal: document.getElementById("uploadModal"), imageUpload: document.getElementById("imageUpload"),
      saveDesign: document.getElementById("saveDesign"), closeModal: document.getElementById("closeModal"),
      handIndicator: document.getElementById("handIndicator"), handText: document.getElementById("handText"),
      title: document.getElementById("title"), subtitle: document.getElementById("subtitle"),
      modalTitle: document.getElementById("modalTitle"), modalDesc: document.getElementById("modalDesc")
    };

    const nailTextures = {}; let scene, camera, renderer; const nails = {}; let handLandmarker;

    const SHADER = {
      vertex: `varying vec2 vUv; varying vec3 vNormal; varying vec3 vView; void main() { vUv = uv; vec4 mv = modelViewMatrix * vec4(position,1.0); vView = -mv.xyz; vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * mv; }`,
      fragment: `uniform sampler2D map; uniform float time; varying vec2 vUv; varying vec3 vNormal; varying vec3 vView; void main() { vec4 t = texture2D(map, vUv); if (t.a < 0.1) discard; vec3 c = t.rgb; float h = pow(smoothstep(0.3,0.7,vUv.y + sin(vUv.y*10.0-time)*0.08),2.0)*0.6; c += vec3(1.0)*h; float r = pow(1.0 - dot(normalize(vView), vNormal), 2.5)*0.3; c += vec3(1.0,0.95,0.9)*r; float s = smoothstep(0.0,0.3,vUv.y); c *= (1.0 - s*0.15); gl_FragColor = vec4(c, t.a); }`
    };

    class Masker {
      constructor() { this.masks = {}; SHAPES.forEach(s => this.masks[s.id] = this.create(s.id)); }
      create(id) {
        const c = document.createElement('canvas'); c.width = 256; c.height = 384; const ctx = c.getContext('2d'); ctx.fillStyle = 'white'; ctx.beginPath();
        const cx = 128, cy = 192;
        switch(id) {
          case 'oval': ctx.ellipse(cx, cy-20, 100, 150, 0, 0, Math.PI*2); break;
          case 'almond': ctx.moveTo(cx,50); ctx.bezierCurveTo(cx+90,80,cx+110,160,cx,340); ctx.bezierCurveTo(cx-110,160,cx-90,80,cx,50); break;
          case 'squoval': ctx.roundRect(60,60,136,264,50); break;
          case 'coffin': ctx.moveTo(60,60); ctx.lineTo(196,60); ctx.lineTo(216,180); ctx.lineTo(196,300); ctx.lineTo(60,300); ctx.lineTo(40,180); ctx.closePath(); break;
          case 'stiletto': ctx.moveTo(cx,40); ctx.lineTo(cx+100,320); ctx.lineTo(cx-100,320); ctx.closePath(); break;
        }
        ctx.fill(); return c;
      }
      async apply(img, shape) {
        const c = document.createElement('canvas'); c.width = 256; c.height = 384; const ctx = c.getContext('2d');
        ctx.drawImage(this.masks[shape], 0, 0); ctx.globalCompositeOperation = 'source-in'; ctx.drawImage(img, 0, 0, 256, 384);
        return new THREE.CanvasTexture(c);
      }
    }
    const masker = new Masker();

    class App {
      async init() {
        this.setupEvents(); await this.setupCamera(); await this.initGL(); await this.setupHand(); this.buildUI(); this.hideLoading(); this.loop();
      }
      setupEvents() {
        el.uploadBtn.onclick = () => el.uploadModal.classList.add('show');
        el.shapeBtn.onclick = () => { state.showShape = !state.showShape; el.shapePicker.style.display = state.showShape ? 'flex' : 'none'; };
        el.langBtn.onclick = () => { state.lang = state.lang === 'en' ? 'ua' : 'en'; el.langBtn.textContent = state.lang === 'en' ? 'UA' : 'EN'; this.updateText(); };
        el.closeModal.onclick = () => { el.uploadModal.classList.remove('show'); el.imageUpload.value = ''; };
        el.saveDesign.onclick = () => this.upload();
        el.allMode.onclick = () => this.setMode(true);
        el.oneMode.onclick = () => this.setMode(false);
        el.canvas.onclick = e => this.click(e);
        window.addEventListener('resize', () => this.resize());
      }
      updateText() {
        const t = TEXT[state.lang];
        el.title.textContent = t.title; el.subtitle.textContent = t.subtitle;
        el.modalTitle.textContent = t.modalTitle; el.modalDesc.textContent = t.modalDesc;
        el.handText.textContent = t.handText; el.saveDesign.textContent = t.save; el.closeModal.textContent = t.cancel;
      }
      setMode(all) { state.isAll = all; el.allMode.classList.toggle('active', all); el.oneMode.classList.toggle('active', !all); }
      async setupCamera() {
        const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: 1280, height: 720 } });
        el.video.srcObject = s; await new Promise(r => el.video.onloadedmetadata = r); el.video.play();
      }
      async initGL() {
        scene = new THREE.Scene(); camera = new THREE.OrthographicCamera(-innerWidth/2, innerWidth/2, innerHeight/2, -innerHeight/2, 0.1, 1000); camera.position.z = 10;
        renderer = new THREE.WebGLRenderer({ canvas: el.canvas, alpha: true, antialias: true }); renderer.setPixelRatio(Math.min(devicePixelRatio, 2)); renderer.setSize(innerWidth, innerHeight);
        this.createNails();
      }
      createNails() {
        const mat = new THREE.ShaderMaterial({ uniforms: { map: { value: null }, time: { value: 0 } }, vertexShader: SHADER.vertex, fragmentShader: SHADER.fragment, transparent: true, side: THREE.DoubleSide });
        FINGER_KEYS.forEach(k => {
          const g = new THREE.PlaneGeometry(CONFIG.NAIL_ASPECT_RATIOS[k], 1); const m = mat.clone(); const mesh = new THREE.Mesh(g, m); mesh.visible = false; nails[k] = mesh; scene.add(mesh);
        });
      }
      async setupHand() {
        const v = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(v, { baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" }, runningMode: "VIDEO", numHands: 1 });
      }
      buildUI() {
        el.colorPicker.innerHTML = ''; COLORS.forEach((c, i) => {
          const b = document.createElement('div'); b.className = `color ${i===0?'selected':''}`; b.style.background = c;
          b.onclick = () => { state.currentColor = c; document.querySelectorAll('.color').forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); this.updateColor(); };
          el.colorPicker.appendChild(b);
        });
        el.shapePicker.innerHTML = ''; SHAPES.forEach(s => {
          const b = document.createElement('div'); b.className = `shape ${s.id===state.currentShape?'selected':''}`; b.textContent = s.icon;
          b.onclick = () => { state.currentShape = s.id; document.querySelectorAll('.shape').forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); };
          el.shapePicker.appendChild(b);
        });
        this.updateColor();
      }
      updateColor() {
        const c = document.createElement('canvas'); c.width = 256; c.height = 384; const ctx = c.getContext('2d');
        const grad = ctx.createLinearGradient(0,0,0,384); grad.addColorStop(0, state.currentColor); grad.addColorStop(1, this.darken(state.currentColor, 0.3));
        ctx.fillStyle = grad; ctx.fillRect(0,0,256,384);
        nailTextures.color = new THREE.CanvasTexture(c);
      }
      darken(hex, f) { let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return `#${((1<<24)+(r*(1-f)<<16)+(g*(1-f)<<8)+b*(1-f)|0).toString(16).slice(1)}`; }
      async upload() {
        const f = el.imageUpload.files[0]; if (!f) return; el.saveDesign.disabled = true; el.saveDesign.textContent = '...';
        const img = new Image(); img.src = URL.createObjectURL(f); await new Promise(r => img.onload = r);
        const tex = await masker.apply(img, state.currentShape); nailTextures.custom = tex; state.currentColor = null;
        el.uploadModal.classList.remove('show'); el.imageUpload.value = ''; el.saveDesign.disabled = false; el.saveDesign.textContent = TEXT[state.lang].save;
      }
      loop() { this.detect(); this.render(); requestAnimationFrame(() => this.loop()); }
      detect() {
        if (!handLandmarker || el.video.readyState < 2) return;
        const r = handLandmarker.detectForVideo(el.video, performance.now());
        if (r.landmarks?.length) { state.handNotDetected = 0; el.handIndicator.classList.remove('show'); const lm = r.landmarks[0]; state.lastLandmarks = this.smooth(lm); this.size(lm); }
        else if (++state.handNotDetected > CONFIG.HAND_NOT_DETECTED_THRESHOLD) { el.handIndicator.classList.add('show'); this.hide(); }
      }
      smooth(lm) { if (!state.smoothed) state.smoothed = lm.map(p=>({...p})); state.smoothed.forEach((s,i)=>{ s.x = this.lerp(s.x, lm[i].x, CONFIG.SMOOTHING_FACTOR); s.y = this.lerp(s.y, lm[i].y, CONFIG.SMOOTHING_FACTOR); }); return state.smoothed; }
      lerp(a,b,t) { return a + (b-a)*t; }
      size(lm) { const d = Math.hypot(lm[0].x-lm[1].x, lm[0].y-lm[1].y); let s = d / CONFIG.WRIST_REF * CONFIG.SCALE_SENS; s = Math.max(CONFIG.MIN_SCALE, Math.min(CONFIG.MAX_SCALE, s)); state.handSize = s; }
      render() {
        if (!state.lastLandmarks) return;
        FINGER_KEYS.forEach((k,i) => {
          const n = nails[k]; if (!state.isAll && i !== state.selectedFinger) { n.visible = false; return; }
          this.updateNail(k); n.visible = true;
        });
        renderer.render(scene, camera);
      }
      updateNail(k) {
        const lm = state.lastLandmarks; const { tip, mcp } = FINGER_INDICES[k]; const t = lm[tip], p = lm[mcp]; const off = CONFIG.NAIL_OFFSETS[k];
        const x = t.x * innerWidth + off.x * innerWidth; const y = (1 - t.y) * innerHeight + off.y * innerHeight;
        const len = Math.hypot((t.x-p.x)*innerWidth, (t.y-p.y)*innerHeight); let size = len * CONFIG.NAIL_SCALE_FACTORS[k] * state.handSize;
        size = Math.max(CONFIG.MIN_SIZE, Math.min(CONFIG.MAX_SIZE, size)); const ang = Math.atan2(t.y-p.y, t.x-p.x);
        const n = nails[k]; n.position.set(x-innerWidth/2, y-innerHeight/2, 0); n.scale.set(size, size, 1); n.rotation.z = ang;
        const tex = nailTextures.custom || nailTextures.color; if (tex) { n.material.uniforms.map.value = tex; n.material.uniforms.time.value = performance.now()*0.001; n.material.needsUpdate = true; }
      }
      click(e) {
        if (state.isAll || !state.lastLandmarks) return;
        const rect = el.canvas.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
        let min = Infinity, idx = -1; FINGER_KEYS.forEach((k,i) => {
          const tip = state.lastLandmarks[FINGER_INDICES[k].tip]; const d = Math.hypot(x - tip.x*innerWidth, y - tip.y*innerHeight);
          if (d < min && d < innerWidth*0.12) { min = d; idx = i; }
        });
        state.selectedFinger = idx;
      }
      hide() { FINGER_KEYS.forEach(k => nails[k].visible = false); renderer.render(scene, camera); }
      resize() { camera.left = -innerWidth/2; camera.right = innerWidth/2; camera.top = innerHeight/2; camera.bottom = -innerHeight/2; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
      hideLoading() { el.loading.style.display = 'none'; el.video.style.display = 'block'; el.canvas.style.display = 'block'; }
    }

    window.addEventListener('DOMContentLoaded', () => new App().init());
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en"> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –Ω–∞ en -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#d4af37">
  <meta name="description" content="Elite Nail AR Studio - realistic virtual manicure with augmented reality">
  
  <title>üíÖ Elite Nail AR Studio</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üíÖ</text></svg>">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üíÖ</text></svg>">

  <style>
    /* –í–µ—Å—å CSS –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –±–µ–∑ –∑–º—ñ–Ω */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
    }
    
    body {
      background: #0a0a0a;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      color: white;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    #video, #canvas, #confettiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }
    #confettiCanvas { z-index: 60; pointer-events: none; display: none; }

    /* === MODERN CONTROL SYSTEM === */
    .control-btn {
      position: fixed;
      width: 56px;
      height: 56px;
      border-radius: 16px;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(40px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #d4af37;
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .control-btn:hover, .control-btn:active {
      transform: scale(1.15);
      border-color: rgba(212, 175, 55, 0.6);
      box-shadow: 0 12px 40px rgba(212, 175, 55, 0.2);
      background: rgba(40, 40, 42, 0.95);
    }

    #langBtn {
      top: calc(20px + env(safe-area-inset-top));
      right: 20px;
      font-weight: 700;
      font-size: 14px;
    }

    #soundBtn {
      top: calc(20px + env(safe-area-inset-top));
      left: 20px;
    }

    #uploadBtn {
      top: calc(90px + env(safe-area-inset-top));
      left: 20px;
    }

    #shapeBtn {
      top: calc(160px + env(safe-area-inset-top));
      left: 20px;
      background: linear-gradient(135deg, #d4af37, #b8941f);
      color: #1c1c1e;
      border: none;
    }

    #screenshotBtn {
      top: calc(230px + env(safe-area-inset-top));
      left: 20px;
    }

    /* Mode Toggle - Modern */
    #modeToggle {
      position: fixed;
      top: calc(20px + env(safe-area-inset-top));
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(40px) saturate(180%);
      padding: 8px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      gap: 8px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .mode-option {
      width: 48px;
      height: 48px;
      border-radius: 14px;
      background: rgba(44, 44, 46, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1.5px solid transparent;
    }

    .mode-option.active {
      background: linear-gradient(135deg, #d4af37, #b8941f);
      color: #1c1c1e;
      transform: scale(1.1);
      box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
    }

    /* Shape Picker - Modern */
    #shapePicker {
      position: fixed;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(40px) saturate(180%);
      padding: 16px 20px;
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 92vw;
      overflow-x: auto;
      scrollbar-width: none;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    #shapePicker::-webkit-scrollbar { 
      display: none; 
    }

    .shape-btn {
      min-width: 75px;
      height: 44px;
      border-radius: 22px;
      border: 1.5px solid rgba(255, 255, 255, 0.15);
      background: rgba(44, 44, 46, 0.8);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      transition: all 0.3s ease;
      color: #ffffff;
      flex-shrink: 0;
      padding: 0 18px;
      font-weight: 600;
    }

    .shape-btn:hover, .shape-btn:active {
      transform: translateY(-2px);
      border-color: rgba(212, 175, 55, 0.5);
      background: rgba(54, 54, 56, 0.8);
    }

    .shape-btn.selected {
      border-color: #d4af37;
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(184, 148, 31, 0.15));
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
    }

    /* Design Picker - Modern */
    #designPicker {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 16px;
      z-index: 100;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(40px) saturate(180%);
      padding: 20px 24px;
      border-radius: 28px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 92vw;
      overflow-x: auto;
      scrollbar-width: none;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    #designPicker::-webkit-scrollbar { 
      display: none; 
    }

    .design-btn {
      width: 80px;
      height: 100px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.15);
      background: rgba(44, 44, 46, 0.8);
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .design-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, transparent 0%, rgba(212, 175, 55, 0.15) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .design-btn:hover::before, .design-btn:active::before {
      opacity: 1;
    }

    .design-btn:hover, .design-btn:active {
      transform: translateY(-4px) scale(1.02);
      border-color: rgba(212, 175, 55, 0.4);
    }

    .design-btn.selected {
      border-color: #d4af37;
      box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.3), 0 12px 40px rgba(212, 175, 55, 0.3);
      transform: scale(1.08);
    }

    .nail-preview {
      width: 60px;
      height: 80px;
      border-radius: 12px;
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, #2c2c2e, #3a3a3c);
    }

    /* Upload Modal - Modern */
    #uploadModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(28, 28, 30, 0.98);
      backdrop-filter: blur(60px) saturate(200%);
      padding: 32px;
      border-radius: 28px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      z-index: 1000;
      display: none;
      color: white;
      text-align: center;
      width: 90%;
      max-width: 440px;
      box-shadow: 0 32px 64px rgba(0, 0, 0, 0.5);
    }

    #uploadModal.show {
      display: block;
      animation: modalAppear 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    #imageUpload {
      margin: 24px 0;
      padding: 20px;
      border: 2px dashed rgba(212, 175, 55, 0.4);
      border-radius: 20px;
      background: rgba(44, 44, 46, 0.6);
      color: white;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
    }

    #imageUpload:hover, #imageUpload:active {
      border-color: rgba(212, 175, 55, 0.6);
      background: rgba(54, 54, 56, 0.6);
    }

    .modal-btn {
      padding: 16px 28px;
      margin: 8px;
      border: none;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
      min-width: 120px;
    }

    #saveDesign {
      background: linear-gradient(135deg, #d4af37, #b8941f);
      color: #1c1c1e;
      box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
    }

    #saveDesign:hover, #saveDesign:active {
      transform: translateY(-2px);
      box-shadow: 0 12px 35px rgba(212, 175, 55, 0.4);
    }

    #closeModal {
      background: rgba(44, 44, 46, 0.8);
      color: #d4af37;
      border: 1.5px solid rgba(212, 175, 55, 0.3);
    }

    #closeModal:hover, #closeModal:active {
      background: rgba(54, 54, 56, 0.8);
      border-color: rgba(212, 175, 55, 0.5);
    }

    /* Loading & Indicators */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #d4af37;
      font-size: 24px;
      text-align: center;
      padding: 30px;
      gap: 25px;
    }

    .loader {
      width: 70px;
      height: 70px;
      border: 3px solid rgba(212, 175, 55, 0.3);
      border-top: 3px solid #d4af37;
      border-radius: 50%;
      animation: spin 1.2s linear infinite;
      box-shadow: 0 0 30px rgba(212, 175, 55, 0.2);
    }

    .indicator {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(28, 28, 30, 0.95);
      color: #d4af37;
      padding: 16px 24px;
      border-radius: 20px;
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 99;
      font-size: 15px;
      border: 1px solid rgba(212, 175, 55, 0.3);
      backdrop-filter: blur(40px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    #handIndicator { 
      top: 180px; 
    }

    .indicator.show {
      display: flex;
      animation: indicatorAppear 0.4s ease;
    }

    .status-message {
      position: fixed;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(28, 28, 30, 0.95);
      color: #d4af37;
      padding: 16px 28px;
      border-radius: 20px;
      z-index: 99;
      font-size: 15px;
      border: 1px solid rgba(212, 175, 55, 0.3);
      backdrop-filter: blur(40px);
      display: none;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .status-message.show {
      display: block;
      animation: fadeInOut 3s ease;
    }

    /* Tooltips */
    .tooltip {
      position: absolute;
      bottom: -40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(28, 28, 30, 0.95);
      color: #d4af37;
      padding: 8px 14px;
      border-radius: 10px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
    }

    .control-btn:hover .tooltip,
    .mode-option:hover .tooltip {
      opacity: 1;
    }

    /* Step Indicator */
    .step-indicator {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #d4af37, #b8941f);
      color: #1c1c1e;
      padding: 6px 16px;
      border-radius: 14px;
      font-size: 12px;
      font-weight: 700;
      white-space: nowrap;
      box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
    }

    /* Platform-specific optimizations */
    @supports (-webkit-touch-callout: none) {
      /* iOS specific styles */
      .control-btn, .mode-option, .design-btn, .shape-btn {
        cursor: default;
      }
    }

    @supports not (-webkit-touch-callout: none) {
      /* Android/Desktop specific styles */
      .control-btn:hover .tooltip,
      .mode-option:hover .tooltip {
        opacity: 1;
      }
    }

    /* Animations */
    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }

    @keyframes modalAppear {
      from {
        opacity: 0;
        transform: translate(-50%, -48%) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    @keyframes indicatorAppear {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    @keyframes confettiFall {
      0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(1000px) rotate(360deg); opacity: 0; }
    }

    /* Mobile Optimizations */
    @media (max-width: 768px) {
      .control-btn {
        width: 52px;
        height: 52px;
        font-size: 20px;
      }

      #langBtn, #soundBtn { top: calc(15px + env(safe-area-inset-top)); }
      #uploadBtn { top: calc(80px + env(safe-area-inset-top)); }
      #shapeBtn { top: calc(145px + env(safe-area-inset-top)); }
      #screenshotBtn { top: calc(210px + env(safe-area-inset-top)); }
      
      #modeToggle { top: calc(15px + env(safe-area-inset-top)); }
      .mode-option { width: 44px; height: 44px; font-size: 18px; }
      
      .design-btn { width: 72px; height: 90px; }
      .nail-preview { width: 54px; height: 72px; }
      
      .shape-btn { min-width: 70px; height: 40px; font-size: 12px; padding: 0 16px; }
      
      #designPicker { bottom: 15px; padding: 18px 22px; }
      #shapePicker { bottom: 125px; padding: 14px 18px; }
    }

    @media (max-width: 480px) {
      .control-btn {
        width: 48px;
        height: 48px;
        font-size: 18px;
      }

      #uploadBtn { top: calc(75px + env(safe-area-inset-top)); }
      #shapeBtn { top: calc(135px + env(safe-area-inset-top)); }
      #screenshotBtn { top: calc(195px + env(safe-area-inset-top)); }
      
      .design-btn { width: 68px; height: 85px; }
      .nail-preview { width: 50px; height: 68px; }
      
      .shape-btn { min-width: 65px; height: 38px; font-size: 11px; padding: 0 14px; }
    }

    /* Foldable devices support */
    @media (max-width: 280px) {
      .control-btn {
        width: 44px;
        height: 44px;
        font-size: 16px;
      }
      
      .design-btn { width: 60px; height: 75px; }
      .nail-preview { width: 44px; height: 60px; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div style="font-weight: 700; margin-bottom: 12px; font-size: 28px;">Elite Nail AR Studio</div>
    <p style="color: #aaa; font-size: 17px; line-height: 1.5; max-width: 300px;">Position your hand in front of the camera<br>Allow camera access</p>
    <div id="platformInfo" style="margin-top: 20px; font-size: 14px; color: #666;"></div>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="confettiCanvas"></canvas>

  <button id="langBtn" class="control-btn" aria-label="Switch language">
    UK <!-- –ó–º—ñ–Ω–∏—Ç–∏ –Ω–∞ UK -->
    <div class="tooltip">Language / –ú–æ–≤–∞</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
  </button>
  
  <button id="soundBtn" class="control-btn" aria-label="Toggle sound">
    üîä
    <div class="tooltip">Sound / –ó–≤—É–∫</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
  </button>
  
  <button id="uploadBtn" class="control-btn" aria-label="Upload design">
    üì§
    <div class="tooltip">Upload / –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
  </button>
  
  <button id="shapeBtn" class="control-btn" aria-label="Nail shapes">
    ‚ú®
    <div class="tooltip">Shapes / –§–æ—Ä–º–∏</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
  </button>

  <button id="screenshotBtn" class="control-btn" aria-label="Take screenshot">
    üì∏
    <div class="tooltip">Screenshot / –ó–Ω—ñ–º–æ–∫</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
  </button>

  <div id="modeToggle">
    <div class="mode-option active" id="applyAllOpt" title="All fingers">
      üíÖ
      <div class="tooltip">All / –£—Å—ñ –ø–∞–ª—å—Ü—ñ</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
    </div>
    <div class="mode-option" id="selectFingerOpt" title="Select finger">
      üëÜ
      <div class="tooltip">Select / –û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å</div> <!-- –ó–º—ñ–Ω–∏—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ -->
    </div>
  </div>

  <!-- Shape Picker - –ö—Ä–æ–∫ 1 -->
  <div id="shapePicker">
    <div class="step-indicator">Step 1: Choose shape</div> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
  </div>

  <!-- Design Picker - –ö—Ä–æ–∫ 2 -->
  <div id="designPicker">
    <div class="step-indicator">Step 2: Choose design</div> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
  </div>

  <div id="uploadModal">
    <h3 style="margin:0;font-weight:700;color:#d4af37;font-size:22px;">üé® Upload Your Design</h3> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
    <p style="margin:16px 0;color:#aaa;font-size:15px;line-height:1.5">Choose an image to create a unique nail design. For best results use PNG with transparent background.</p> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
    <input type="file" id="imageUpload" accept="image/*">
    <div style="margin-top: 24px;">
      <button id="saveDesign" class="modal-btn">üíæ Save</button> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
      <button id="closeModal" class="modal-btn">‚ùå Cancel</button> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
    </div>
  </div>

  <div id="handIndicator" class="indicator">
    <span>üëã</span>
    <span>Show your hand to the camera</span> <!-- –ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º -->
  </div>

  <div class="status-message" id="statusMessage"></div>

  <script>
    // PWA Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => console.log('SW registered'))
          .catch(err => console.log('SW registration failed'));
      });
    }

    // Platform detection
    function detectPlatform() {
      const platformInfo = document.getElementById('platformInfo');
      const userAgent = navigator.userAgent;
      
      if (/iPhone|iPad|iPod/.test(userAgent)) {
        platformInfo.textContent = 'üì± iOS ‚Ä¢ Safari ‚Ä¢ AR Ready';
      } else if (/Android/.test(userAgent)) {
        platformInfo.textContent = 'üì± Android ‚Ä¢ Chrome ‚Ä¢ ARCore Ready';
      } else {
        platformInfo.textContent = 'üíª Desktop ‚Ä¢ WebXR Ready';
      }
    }
  </script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    // === ADVANCED CONFIGURATION ===
    const CONFIG = {
      SMOOTHING_FACTOR: 0.8,
      HAND_NOT_DETECTED_THRESHOLD: 15,
      NAIL_SCALE_FACTORS: { 
        thumb: 0.42, index: 0.52, middle: 0.56, ring: 0.52, pinky: 0.40 
      },
      NAIL_OFFSETS: {
        thumb: { x: -0.015, y: -0.032 },
        index: { x: 0, y: -0.028 },
        middle: { x: 0, y: -0.035 },
        ring: { x: 0, y: -0.028 },
        pinky: { x: 0.010, y: -0.022 }
      },
      MIN_SIZE: 30,
      MAX_SIZE: 95,
      WRIST_DISTANCE_REF: 0.085,
      SCALE_SENSITIVITY: 2.2,
      PERFORMANCE: {
        MAX_FPS: 60,
        QUALITY: window.devicePixelRatio > 2 ? 'high' : 'medium'
      }
    };

    const FINGER_INDICES = {
      thumb: { tip: 4, mcp: 2, pip: 3 },
      index: { tip: 8, mcp: 5, pip: 6 },
      middle: { tip: 12, mcp: 9, pip: 10 },
      ring: { tip: 16, mcp: 13, pip: 14 },
      pinky: { tip: 20, mcp: 17, pip: 18 }
    };

    const FINGER_KEYS = Object.keys(FINGER_INDICES);

    // === REALISTIC NAIL SHAPES ===
    const NAIL_SHAPES = [
      { 
        id: 'oval', 
        name: { en: 'Oval', uk: '–û–≤–∞–ª' },
        curvature: 0.3,
        length: 1.2
      },
      { 
        id: 'almond', 
        name: { en: 'Almond', uk: '–ú–∏–Ω–¥–∞–ª—å' },
        curvature: 0.4,
        length: 1.4
      },
      { 
        id: 'squoval', 
        name: { en: 'Squoval', uk: '–°–∫—É–≤–∞–ª' },
        curvature: 0.2,
        length: 1.1
      },
      { 
        id: 'coffin', 
        name: { en: 'Coffin', uk: '–ì—Ä–æ–±' },
        curvature: 0.5,
        length: 1.5
      },
      { 
        id: 'stiletto', 
        name: { en: 'Stiletto', uk: '–°—Ç—ñ–ª–µ—Ç—Ç–æ' },
        curvature: 0.6,
        length: 1.6
      },
      { 
        id: 'square', 
        name: { en: 'Square', uk: '–ö–≤–∞–¥—Ä–∞—Ç' },
        curvature: 0.1,
        length: 1.0
      },
      { 
        id: 'rounded_square', 
        name: { en: 'Rounded Square', uk: '–ú—è–∫–∏–π –∫–≤–∞–¥—Ä–∞—Ç' },
        curvature: 0.15,
        length: 1.05
      },
      { 
        id: 'ballerina', 
        name: { en: 'Ballerina', uk: '–ë–∞–ª–µ—Ä–∏–Ω–∞' },
        curvature: 0.45,
        length: 1.3
      }
    ];

    // === TRANSLATIONS - –ó–ú–Ü–ù–ò–¢–ò –ü–û–†–Ø–î–û–ö, –ê–ù–ì–õ–Ü–ô–°–¨–ö–ê –ü–ï–†–®–ê ===
    const translations = {
      en: { // –û—Å–Ω–æ–≤–Ω–∞ –º–æ–≤–∞ - –∞–Ω–≥–ª—ñ–π—Å—å–∫–∞
        title: "üíÖ Elite Nail AR Studio",
        loading: "Loading AR Experience...",
        cameraPrompt: "Position your hand in front of the camera",
        allFingers: "All Fingers",
        selectFinger: "Select Finger",
        handNotDetected: "Show your hand to the camera",
        uploadTitle: "üé® Upload Your Design",
        uploadHint: "Choose an image to create a unique nail design. For best results use PNG with transparent background.",
        save: "üíæ Save",
        cancel: "‚ùå Cancel",
        designSaved: "üéâ Design saved successfully!",
        screenshotSaved: "üì∏ Screenshot saved!",
        shapeChanged: "Shape changed to: ",
        modeAll: "Mode: All fingers",
        modeSingle: "Mode: Single finger - tap on screen",
        step1: "Step 1: Choose shape",
        step2: "Step 2: Choose design",
        platformIOS: "üì± iOS ‚Ä¢ Safari ‚Ä¢ AR Ready",
        platformAndroid: "üì± Android ‚Ä¢ Chrome ‚Ä¢ ARCore Ready",
        platformDesktop: "üíª Desktop ‚Ä¢ WebXR Ready"
      },
      uk: { // –î—Ä—É–≥–∞ –º–æ–≤–∞ - —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞
        title: "üíÖ Elite Nail AR Studio",
        loading: "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è AR –¥–æ—Å–≤—ñ–¥—É...",
        cameraPrompt: "–ü–æ–∫–ª–∞–¥—ñ—Ç—å —Ä—É–∫—É –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ—é",
        allFingers: "–£—Å—ñ –ø–∞–ª—å—Ü—ñ",
        selectFinger: "–û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å",
        handNotDetected: "–ü–æ–∫–∞–∂—ñ—Ç—å —Ä—É–∫—É –∫–∞–º–µ—Ä—ñ",
        uploadTitle: "üé® –ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å–≤—ñ–π –¥–∏–∑–∞–π–Ω",
        uploadHint: "–û–±–µ—Ä—ñ—Ç—å –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —É–Ω—ñ–∫–∞–ª—å–Ω–æ–≥–æ –¥–∏–∑–∞–π–Ω—É –Ω—ñ–≥—Ç—ñ–≤. –î–ª—è –Ω–∞–π–∫—Ä–∞—â–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ PNG –∑ –ø—Ä–æ–∑–æ—Ä–∏–º —Ñ–æ–Ω–æ–º.",
        save: "üíæ –ó–±–µ—Ä–µ–≥—Ç–∏",
        cancel: "‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏",
        designSaved: "üéâ –î–∏–∑–∞–π–Ω —É—Å–ø—ñ—à–Ω–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!",
        screenshotSaved: "üì∏ –ó–Ω—ñ–º–æ–∫ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!",
        shapeChanged: "–§–æ—Ä–º–∞ –∑–º—ñ–Ω–µ–Ω–∞ –Ω–∞: ",
        modeAll: "–†–µ–∂–∏–º: –≤—Å—ñ –ø–∞–ª—å—Ü—ñ",
        modeSingle: "–†–µ–∂–∏–º: –æ–¥–∏–Ω –ø–∞–ª–µ—Ü—å - —Ç–æ—Ä–∫–Ω—ñ—Ç—å—Å—è –µ–∫—Ä–∞–Ω—É",
        step1: "–ö—Ä–æ–∫ 1: –û–±—Ä–∞—Ç–∏ —Ñ–æ—Ä–º—É",
        step2: "–ö—Ä–æ–∫ 2: –û–±—Ä–∞—Ç–∏ –¥–∏–∑–∞–π–Ω",
        platformIOS: "üì± iOS ‚Ä¢ Safari ‚Ä¢ AR –≥–æ—Ç–æ–≤–∏–π",
        platformAndroid: "üì± Android ‚Ä¢ Chrome ‚Ä¢ ARCore –≥–æ—Ç–æ–≤–∏–π",
        platformDesktop: "üíª Desktop ‚Ä¢ WebXR –≥–æ—Ç–æ–≤–∏–π"
      }
    };

    // === STATE MANAGEMENT - –ó–ú–Ü–ù–ò–¢–ò –ü–û–ß–ê–¢–ö–û–í–£ –ú–û–í–£ ===
    const state = {
      currentLang: 'en', // –ó–º—ñ–Ω–∏—Ç–∏ –Ω–∞ 'en' –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
      currentDesign: "luxury_gold",
      currentShape: 'oval',
      isApplyAll: true,
      selectedFingerIndex: -1,
      isMuted: false,
      lastLandmarks: null,
      smoothedLandmarks: null,
      handNotDetectedCount: 0,
      currentHandSize: 1.0,
      isLeftHand: false,
      customDesigns: [],
      showShapePicker: true,
      isWebXRAvailable: false,
      platform: 'unknown'
    };

    // === DOM ELEMENTS ===
    const el = {
      video: document.getElementById("video"),
      canvas: document.getElementById("canvas"),
      confettiCanvas: document.getElementById("confettiCanvas"),
      loading: document.getElementById("loading"),
      langBtn: document.getElementById("langBtn"),
      soundBtn: document.getElementById("soundBtn"),
      uploadBtn: document.getElementById("uploadBtn"),
      shapeBtn: document.getElementById("shapeBtn"),
      screenshotBtn: document.getElementById("screenshotBtn"),
      applyAllOpt: document.getElementById("applyAllOpt"),
      selectFingerOpt: document.getElementById("selectFingerOpt"),
      designPicker: document.getElementById("designPicker"),
      shapePicker: document.getElementById("shapePicker"),
      uploadModal: document.getElementById("uploadModal"),
      imageUpload: document.getElementById("imageUpload"),
      saveDesign: document.getElementById("saveDesign"),
      closeModal: document.getElementById("closeModal"),
      handIndicator: document.getElementById("handIndicator"),
      statusMessage: document.getElementById("statusMessage")
    };

    // === ADVANCED AUDIO SYSTEM ===
    const audio = {
      context: null,
      click: null,
      success: null,
      
      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.createSounds();
        } catch (error) {
          console.warn('Audio context not supported');
        }
      },
      
      createSounds() {
        // Click sound
        this.click = () => {
          if (state.isMuted || !this.context) return;
          
          const oscillator = this.context.createOscillator();
          const gainNode = this.context.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(this.context.destination);
          
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
          
          oscillator.start(this.context.currentTime);
          oscillator.stop(this.context.currentTime + 0.1);
        };
        
        // Success sound
        this.success = () => {
          if (state.isMuted || !this.context) return;
          
          const oscillator = this.context.createOscillator();
          const gainNode = this.context.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(this.context.destination);
          
          oscillator.frequency.setValueAtTime(523.25, this.context.currentTime);
          oscillator.frequency.setValueAtTime(659.25, this.context.currentTime + 0.1);
          oscillator.frequency.setValueAtTime(783.99, this.context.currentTime + 0.2);
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.4, this.context.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
          
          oscillator.start(this.context.currentTime);
          oscillator.stop(this.context.currentTime + 0.3);
        };
      },
      
      play(sound) {
        if (state.isMuted || !this.context) return;
        
        // Resume context if suspended (iOS requirement)
        if (this.context.state === 'suspended') {
          this.context.resume();
        }
        
        sound();
      }
    };

    // === ADVANCED THREE.JS SETUP ===
    const nailTextures = {};
    let scene, camera, renderer;
    const nails = {};
    let handLandmarker;
    const confettiCtx = el.confettiCanvas.getContext("2d");
    let confettiParticles = [];

    // === REALISTIC NAIL SHADER ===
    const REALISTIC_NAIL_SHADER = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vViewPosition = -mvPosition.xyz;
          
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      
      fragmentShader: `
        uniform sampler2D map;
        uniform sampler2D normalMap;
        uniform float time;
        uniform float shine;
        uniform vec3 nailColor;
        uniform vec3 lightPosition;
        uniform float curvature;
        uniform float nailLength;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        
        // Noise function for realistic imperfections
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          
          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }
        
        void main() {
          vec4 tex = texture2D(map, vUv);
          if (tex.a < 0.1) discard;
          
          // Base color with texture
          vec3 color = mix(nailColor, tex.rgb, 0.8);
          
          // Realistic nail curvature effect
          float curve = curvature * 0.5;
          float curveEffect = smoothstep(0.0, 1.0, vUv.y * nailLength) * curve;
          
          // Dynamic highlights based on curvature
          float highlight = pow(smoothstep(0.2, 0.8, vUv.y + sin(vUv.y * 12.0 - time * 2.0) * 0.03), 3.0) * shine;
          color += vec3(1.0, 0.98, 0.95) * highlight * 0.6;
          
          // Rim lighting for 3D effect
          float rim = pow(1.0 - dot(normalize(vViewPosition), vNormal), 4.0) * 0.3;
          color += vec3(1.0, 0.98, 0.92) * rim;
          
          // Subtle shadow from cuticle
          float shadow = smoothstep(0.0, 0.3, vUv.y);
          color *= (1.0 - shadow * 0.15);
          
          // Micro-imperfections for realism
          float microNoise = noise(vUv * 50.0) * 0.02;
          color += vec3(microNoise);
          
          // Tip gradient for natural look
          float tipGradient = smoothstep(0.7, 1.0, vUv.y);
          color = mix(color, color * 0.9, tipGradient * 0.3);
          
          // Final color adjustment
          color = pow(color, vec3(1.1)); // Gamma correction
          
          gl_FragColor = vec4(color, tex.a);
        }
      `
    };

    // === REALISTIC NAIL RENDERER ===
    class RealisticNailRenderer {
      constructor() {
        this.masks = {};
        this.normalMaps = {};
        this.initResources();
      }

      initResources() {
        NAIL_SHAPES.forEach(shape => {
          this.masks[shape.id] = this.createShapeMask(shape.id);
          this.normalMaps[shape.id] = this.createNormalMap(shape.id);
        });
      }

      createShapeMask(shape) {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 768; // Higher resolution for better quality
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.beginPath();

        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const baseY = height * 0.8;

        switch(shape) {
          case 'oval':
            ctx.ellipse(centerX, height/2, width*0.35, height*0.4, 0, 0, Math.PI * 2);
            break;
          case 'almond':
            this.drawAlmondShape(ctx, centerX, height/2, width*0.4, height*0.45);
            break;
          case 'squoval':
            ctx.roundRect(width*0.2, height*0.2, width*0.6, height*0.6, 80);
            break;
          case 'coffin':
            this.drawCoffinShape(ctx, centerX, height/2, width*0.35, height*0.5);
            break;
          case 'stiletto':
            this.drawStilettoShape(ctx, centerX, height/2, width*0.3, height*0.55);
            break;
          case 'square':
            ctx.rect(width*0.25, height*0.25, width*0.5, height*0.5);
            break;
          case 'rounded_square':
            ctx.roundRect(width*0.25, height*0.25, width*0.5, height*0.5, 40);
            break;
          case 'ballerina':
            this.drawBallerinaShape(ctx, centerX, height/2, width*0.38, height*0.48);
            break;
        }

        ctx.fill();
        return canvas;
      }

      drawAlmondShape(ctx, x, y, width, height) {
        ctx.moveTo(x, y - height/2);
        ctx.bezierCurveTo(x + width/2, y - height/3, x + width/2, y + height/3, x, y + height/2);
        ctx.bezierCurveTo(x - width/2, y + height/3, x - width/2, y - height/3, x, y - height/2);
        ctx.closePath();
      }

      drawCoffinShape(ctx, x, y, width, height) {
        const tipWidth = width * 0.7;
        ctx.moveTo(x - width/2, y - height/2);
        ctx.lineTo(x + width/2, y - height/2);
        ctx.lineTo(x + tipWidth/2, y + height/2);
        ctx.lineTo(x - tipWidth/2, y + height/2);
        ctx.closePath();
      }

      drawStilettoShape(ctx, x, y, width, height) {
        ctx.moveTo(x, y - height/2);
        ctx.lineTo(x + width/2, y);
        ctx.lineTo(x + width/3, y + height/2);
        ctx.lineTo(x - width/3, y + height/2);
        ctx.lineTo(x - width/2, y);
        ctx.closePath();
      }

      drawBallerinaShape(ctx, x, y, width, height) {
        ctx.moveTo(x - width/2, y - height/3);
        ctx.lineTo(x + width/2, y - height/3);
        ctx.lineTo(x + width/2, y - height/6);
        ctx.lineTo(x + width/3, y + height/2);
        ctx.lineTo(x - width/3, y + height/2);
        ctx.lineTo(x - width/2, y - height/6);
        ctx.closePath();
      }

      createNormalMap(shape) {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 768;
        const ctx = canvas.getContext('2d');
        
        // Create realistic normal map for 3D lighting
        const gradient = ctx.createRadialGradient(256, 384, 0, 256, 384, 400);
        gradient.addColorStop(0, 'rgb(127,127,255)');
        gradient.addColorStop(1, 'rgb(127,127,127)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 768);
        
        return new THREE.CanvasTexture(canvas);
      }

      async processImage(img, shape = 'oval') {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 768;
        const ctx = canvas.getContext('2d');

        // Apply shape mask
        ctx.drawImage(this.masks[shape], 0, 0);
        ctx.globalCompositeOperation = 'source-in';
        ctx.drawImage(img, 0, 0, 512, 768);
        ctx.globalCompositeOperation = 'source-over';

        // Add realistic shine and highlights
        const shine = ctx.createLinearGradient(0, 0, 0, 768);
        shine.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        shine.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
        shine.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
        ctx.fillStyle = shine;
        ctx.globalAlpha = 0.4;
        ctx.fillRect(0, 0, 512, 768);
        ctx.globalAlpha = 1;

        return new THREE.CanvasTexture(canvas);
      }

      createPreview(imageData, shape = 'oval', size = 80) {
        return new Promise((resolve) => {
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');

          ctx.fillStyle = 'white';
          ctx.beginPath();

          const center = size / 2;
          switch(shape) {
            case 'oval':
              ctx.ellipse(center, center, size/2.8, size/2.2, 0, 0, 2 * Math.PI);
              break;
            case 'almond':
              this.drawAlmondShape(ctx, center, center, size*0.9, size*0.8);
              break;
            case 'squoval':
              ctx.roundRect(size*0.15, size*0.15, size*0.7, size*0.7, 12);
              break;
            case 'coffin':
              this.drawCoffinShape(ctx, center, center, size*0.7, size*0.8);
              break;
            case 'stiletto':
              this.drawStilettoShape(ctx, center, center, size*0.6, size*0.85);
              break;
            case 'square':
              ctx.rect(size*0.2, size*0.2, size*0.6, size*0.6);
              break;
            case 'rounded_square':
              ctx.roundRect(size*0.2, size*0.2, size*0.6, size*0.6, 8);
              break;
            case 'ballerina':
              this.drawBallerinaShape(ctx, center, center, size*0.75, size*0.75);
              break;
          }

          ctx.fill();
          ctx.globalCompositeOperation = 'source-in';

          const previewImg = new Image();
          previewImg.onload = () => {
            ctx.drawImage(previewImg, 0, 0, size, size);
            resolve(canvas.toDataURL());
          };
          previewImg.src = imageData;
        });
      }
    }

    const realisticRenderer = new RealisticNailRenderer();

    // === MAIN APPLICATION ===
    class EliteNailARStudio {
      async init() {
        try {
          this.detectPlatform();
          audio.init();
          this.setupEventListeners();
          await this.setupCamera();
          await this.initWebGL();
          await this.setupHandTracking();
          await this.loadProfessionalDesigns();
          this.buildUI();
          this.hideLoading();
          this.startRenderLoop();
          this.showStatus(this.t('cameraPrompt'));
        } catch (error) {
          console.error('Initialization error:', error);
          this.showError('Initialization error. Check camera access and refresh the page.');
        }
      }

      detectPlatform() {
        const userAgent = navigator.userAgent;
        
        if (/iPhone|iPad|iPod/.test(userAgent)) {
          state.platform = 'ios';
          document.body.classList.add('platform-ios');
        } else if (/Android/.test(userAgent)) {
          state.platform = 'android';
          document.body.classList.add('platform-android');
        } else {
          state.platform = 'desktop';
          document.body.classList.add('platform-desktop');
        }
        
        // Check WebXR availability
        if ('xr' in navigator) {
          navigator.xr.isSessionSupported('immersive-ar')
            .then(supported => {
              state.isWebXRAvailable = supported;
            })
            .catch(() => {
              state.isWebXRAvailable = false;
            });
        }
      }

      t(key) {
        return translations[state.currentLang][key] || key;
      }

      setupEventListeners() {
        // Audio context unlock on first interaction
        const unlockAudio = () => {
          if (audio.context && audio.context.state === 'suspended') {
            audio.context.resume();
          }
          document.removeEventListener('click', unlockAudio);
          document.removeEventListener('touchstart', unlockAudio);
        };
        document.addEventListener('click', unlockAudio);
        document.addEventListener('touchstart', unlockAudio);

        el.langBtn.onclick = () => this.toggleLanguage();
        el.soundBtn.onclick = () => this.toggleSound();
        el.uploadBtn.onclick = () => this.showUploadModal();
        el.shapeBtn.onclick = () => this.toggleShapePicker();
        el.screenshotBtn.onclick = () => this.takeScreenshot();
        el.applyAllOpt.onclick = () => this.setApplicationMode(true);
        el.selectFingerOpt.onclick = () => this.setApplicationMode(false);
        el.saveDesign.onclick = () => this.handleImageUpload();
        el.closeModal.onclick = () => this.hideUploadModal();
        
        el.canvas.onclick = (event) => this.handleCanvasClick(event);
        
        window.addEventListener('resize', () => this.handleResize());
        
        // Handle PWA installation
        window.addEventListener('beforeinstallprompt', (e) => {
          e.preventDefault();
          // Can show install button here
        });
        
        document.addEventListener('click', (event) => {
          if (!el.shapePicker.contains(event.target) && event.target !== el.shapeBtn) {
            this.hideShapePicker();
          }
        });

        // Handle visibility change for performance
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            this.pauseRendering();
          } else {
            this.resumeRendering();
          }
        });
      }

      toggleLanguage() {
        state.currentLang = state.currentLang === 'en' ? 'uk' : 'en';
        this.updateUI();
        audio.play(audio.click);
      }

      toggleSound() {
        state.isMuted = !state.isMuted;
        el.soundBtn.textContent = state.isMuted ? 'üîá' : 'üîä';
        audio.play(audio.click);
      }

      toggleShapePicker() {
        state.showShapePicker = !state.showShapePicker;
        el.shapePicker.style.display = state.showShapePicker ? 'flex' : 'none';
        audio.play(audio.click);
      }

      hideShapePicker() {
        state.showShapePicker = false;
        el.shapePicker.style.display = 'none';
      }

      setApplicationMode(applyToAll) {
        state.isApplyAll = applyToAll;
        el.applyAllOpt.classList.toggle('active', applyToAll);
        el.selectFingerOpt.classList.toggle('active', !applyToAll);
        
        this.showStatus(applyToAll ? this.t('modeAll') : this.t('modeSingle'));
        audio.play(audio.click);
      }

      showUploadModal() {
        el.uploadModal.classList.add('show');
        this.hideShapePicker();
        audio.play(audio.click);
      }

      hideUploadModal() {
        el.uploadModal.classList.remove('show');
        el.imageUpload.value = '';
      }

      async handleImageUpload() {
        const file = el.imageUpload.files[0];
        if (!file) {
          alert("Please select an image file.");
          return;
        }

        if (file.size > 8 * 1024 * 1024) {
          alert("Please select an image smaller than 8MB.");
          return;
        }

        try {
          el.saveDesign.textContent = 'Processing...';
          el.saveDesign.disabled = true;

          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = () => reject(new Error("Failed to load image"));
            img.src = URL.createObjectURL(file);
          });

          const texture = await realisticRenderer.processImage(img, state.currentShape);
          const designId = `custom_${Date.now()}`;
          nailTextures[designId] = texture;
          state.currentDesign = designId;

          const previewUrl = await realisticRenderer.createPreview(img.src, state.currentShape);
          
          const button = document.createElement('div');
          button.className = 'design-btn selected';
          button.style.backgroundImage = `url(${previewUrl})`;
          button.style.backgroundSize = 'cover';
          button.onclick = () => {
            state.currentDesign = designId;
            document.querySelectorAll('.design-btn').forEach(btn => {
              btn.classList.remove('selected');
            });
            button.classList.add('selected');
            this.triggerConfetti();
          };

          el.designPicker.appendChild(button);
          el.uploadModal.classList.remove('show');
          el.imageUpload.value = '';
          
          this.showSuccessMessage(this.t('designSaved'));
          this.triggerConfetti();
          audio.play(audio.success);
          
        } catch (error) {
          alert("Failed to process image. Please try a different file.");
        } finally {
          el.saveDesign.textContent = this.t('save');
          el.saveDesign.disabled = false;
        }
      }

      triggerConfetti() {
        const rect = el.designPicker.getBoundingClientRect();
        for (let i = 0; i < 35; i++) {
          confettiParticles.push(new ConfettiParticle(
            rect.left + Math.random() * rect.width,
            rect.top + Math.random() * rect.height
          ));
        }
        el.confettiCanvas.style.display = 'block';
      }

      updateConfetti() {
        confettiParticles = confettiParticles.filter(p => p.life > 0);
        confettiParticles.forEach(p => p.update());
        
        confettiCtx.clearRect(0, 0, el.confettiCanvas.width, el.confettiCanvas.height);
        confettiParticles.forEach(p => p.draw(confettiCtx));
        
        if (confettiParticles.length === 0) {
          el.confettiCanvas.style.display = 'none';
        }
      }

      async setupCamera() {
        try {
          const constraints = {
            video: { 
              facingMode: "environment",
              width: { ideal: 1920 },
              height: { ideal: 1080 },
              frameRate: { ideal: 60 }
            }
          };

          // Adjust constraints based on platform
          if (state.platform === 'ios') {
            constraints.video.frameRate = { ideal: 30 }; // Better performance on iOS
          }

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          el.video.srcObject = stream;
          
          await new Promise(resolve => {
            el.video.onloadedmetadata = () => resolve();
          });
          
          el.video.play();
        } catch (error) {
          throw new Error("Camera access denied or not supported");
        }
      }

      async initWebGL() {
        scene = new THREE.Scene();
        
        // Use perspective camera for more realistic 3D
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.1, 
          1000
        );
        camera.position.z = 5;
        
        renderer = new THREE.WebGLRenderer({ 
          canvas: el.canvas, 
          alpha: true, 
          antialias: true,
          precision: 'highp',
          powerPreference: 'high-performance'
        });
        
        // Optimize for platform
        const pixelRatio = state.platform === 'ios' ? 
          Math.min(window.devicePixelRatio, 2) : 
          Math.min(window.devicePixelRatio, 1.5);
          
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        
        this.createRealisticNailMeshes();
      }

      createRealisticNailMeshes() {
        const nailMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: null },
            normalMap: { value: null },
            time: { value: 0 },
            shine: { value: 1.0 },
            nailColor: { value: new THREE.Color(0.95, 0.92, 0.88) },
            lightPosition: { value: new THREE.Vector3(10, 10, 10) },
            curvature: { value: 0.3 },
            nailLength: { value: 1.2 }
          },
          vertexShader: REALISTIC_NAIL_SHADER.vertexShader,
          fragmentShader: REALISTIC_NAIL_SHADER.fragmentShader,
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false
        });

        FINGER_KEYS.forEach(finger => {
          // Use curved geometry for more realistic nails
          const geometry = new THREE.PlaneGeometry(0.8, 1.2, 16, 24);
          
          // Add slight curvature to the nail
          const positions = geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            const y = positions[i + 1];
            const curve = Math.sin(y * Math.PI) * 0.1;
            positions[i + 2] = curve; // z-position for curvature
          }
          geometry.attributes.position.needsUpdate = true;
          geometry.computeVertexNormals();
          
          const material = nailMaterial.clone();
          const mesh = new THREE.Mesh(geometry, material);
          mesh.visible = false;
          mesh.frustumCulled = false;
          mesh.renderOrder = 1;
          
          nails[finger] = mesh;
          scene.add(mesh);
        });
      }

      async setupHandTracking() {
        try {
          const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
          );
          
          handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
              delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
          });
        } catch (error) {
          console.error('Hand tracking initialization failed:', error);
          throw new Error("Hand tracking initialization error");
        }
      }

      async loadProfessionalDesigns() {
        const designs = [
          this.createLuxuryGold(),
          this.createClassicRed(),
          this.createFrenchManicure(),
          this.createGlitterPink(),
          this.createMarble(),
          this.createOmbre(),
          this.createGelNude(),
          this.createChromeSilver()
        ];
        
        await Promise.all(designs);
      }

      createLuxuryGold() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          const gradient = ctx.createLinearGradient(0, 0, 0, 768);
          gradient.addColorStop(0, '#ffd700');
          gradient.addColorStop(0.2, '#f4c430');
          gradient.addColorStop(0.5, '#daa520');
          gradient.addColorStop(0.8, '#b8860b');
          gradient.addColorStop(1, '#8b6914');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 512, 768);
          
          // Add metallic flakes
          for (let i = 0; i < 200; i++) {
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.4 + 0.3})`;
            const x = Math.random() * 512;
            const y = Math.random() * 768;
            const size = Math.random() * 4 + 1;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          nailTextures["luxury_gold"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createClassicRed() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          const redGrad = ctx.createLinearGradient(0, 0, 0, 768);
          redGrad.addColorStop(0, '#DC143C');
          redGrad.addColorStop(0.3, '#C41E3A');
          redGrad.addColorStop(0.7, '#8B0000');
          redGrad.addColorStop(1, '#800000');
          ctx.fillStyle = redGrad;
          ctx.fillRect(0, 0, 512, 768);
          
          const shine = ctx.createRadialGradient(256, 200, 0, 256, 200, 400);
          shine.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
          shine.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = shine;
          ctx.fillRect(0, 0, 512, 768);
          
          nailTextures["classic_red"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createFrenchManicure() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          // Natural nail base
          const baseGrad = ctx.createLinearGradient(0, 0, 0, 768);
          baseGrad.addColorStop(0, '#FFF8F0');
          baseGrad.addColorStop(0.5, '#FFE8CC');
          baseGrad.addColorStop(1, '#FFD8B0');
          ctx.fillStyle = baseGrad;
          ctx.fillRect(0, 0, 512, 768);
          
          // French tip
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.moveTo(100, 600);
          ctx.bezierCurveTo(200, 550, 312, 550, 412, 600);
          ctx.lineTo(412, 768);
          ctx.lineTo(100, 768);
          ctx.closePath();
          ctx.fill();
          
          // Subtle smile line
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(120, 580);
          ctx.bezierCurveTo(200, 560, 312, 560, 392, 580);
          ctx.stroke();
          
          nailTextures["french_manicure"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createGlitterPink() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          const pinkGrad = ctx.createLinearGradient(0, 0, 0, 768);
          pinkGrad.addColorStop(0, '#ffb6e1');
          pinkGrad.addColorStop(0.3, '#ff85c8');
          pinkGrad.addColorStop(0.7, '#ff66b2');
          pinkGrad.addColorStop(1, '#ff1493');
          ctx.fillStyle = pinkGrad;
          ctx.fillRect(0, 0, 512, 768);
          
          const glitterColors = ['#ff99cc', '#ff66aa', '#ffffff', '#ffccdd', '#ffb3e6'];
          for (let i = 0; i < 300; i++) {
            ctx.fillStyle = glitterColors[Math.floor(Math.random() * glitterColors.length)];
            ctx.globalAlpha = Math.random() * 0.7 + 0.2;
            const x = Math.random() * 512;
            const y = Math.random() * 768;
            const size = Math.random() * 5 + 1;
            const rotation = Math.random() * Math.PI;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.restore();
          }
          
          nailTextures["glitter_pink"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createMarble() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          // Marble base
          ctx.fillStyle = '#F8F8FF';
          ctx.fillRect(0, 0, 512, 768);
          
          // Marble veins
          ctx.strokeStyle = '#E8E8E8';
          ctx.lineWidth = 12;
          ctx.lineCap = 'round';
          
          for (let i = 0; i < 20; i++) {
            ctx.beginPath();
            const startX = Math.random() * 512;
            const startY = Math.random() * 768;
            ctx.moveTo(startX, startY);
            
            for (let j = 0; j < 3; j++) {
              ctx.bezierCurveTo(
                Math.random() * 512, Math.random() * 768,
                Math.random() * 512, Math.random() * 768,
                Math.random() * 512, Math.random() * 768
              );
            }
            ctx.stroke();
          }
          
          // Subtle highlights
          const highlight = ctx.createRadialGradient(128, 192, 0, 128, 192, 300);
          highlight.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
          highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = highlight;
          ctx.fillRect(0, 0, 512, 768);
          
          nailTextures["marble"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createOmbre() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          const ombreGrad = ctx.createLinearGradient(0, 0, 0, 768);
          ombreGrad.addColorStop(0, '#FF69B4');
          ombreGrad.addColorStop(0.3, '#FF1493');
          ombreGrad.addColorStop(0.6, '#DC143C');
          ombreGrad.addColorStop(1, '#8B0000');
          ctx.fillStyle = ombreGrad;
          ctx.fillRect(0, 0, 512, 768);
          
          nailTextures["ombre"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createGelNude() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          const nudeGrad = ctx.createLinearGradient(0, 0, 0, 768);
          nudeGrad.addColorStop(0, '#FFF8F0');
          nudeGrad.addColorStop(0.5, '#F5E6D3');
          nudeGrad.addColorStop(1, '#E8D5C4');
          ctx.fillStyle = nudeGrad;
          ctx.fillRect(0, 0, 512, 768);
          
          // Gel shine effect
          const shine = ctx.createLinearGradient(0, 0, 512, 0);
          shine.addColorStop(0, 'rgba(255, 255, 255, 0)');
          shine.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
          shine.addColorStop(0.7, 'rgba(255, 255, 255, 0.4)');
          shine.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = shine;
          ctx.fillRect(0, 0, 512, 768);
          
          nailTextures["gel_nude"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      createChromeSilver() {
        return new Promise(resolve => {
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 768;
          const ctx = canvas.getContext('2d');
          
          const chromeGrad = ctx.createLinearGradient(0, 0, 512, 768);
          chromeGrad.addColorStop(0, '#F8F8FF');
          chromeGrad.addColorStop(0.2, '#E8E8E8');
          chromeGrad.addColorStop(0.5, '#D3D3D3');
          chromeGrad.addColorStop(0.8, '#C0C0C0');
          chromeGrad.addColorStop(1, '#A9A9A9');
          ctx.fillStyle = chromeGrad;
          ctx.fillRect(0, 0, 512, 768);
          
          // Mirror-like reflection
          const reflection = ctx.createLinearGradient(100, 0, 400, 768);
          reflection.addColorStop(0, 'rgba(255, 255, 255, 0)');
          reflection.addColorStop(0.4, 'rgba(255, 255, 255, 0.6)');
          reflection.addColorStop(0.6, 'rgba(255, 255, 255, 0.6)');
          reflection.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = reflection;
          ctx.fillRect(0, 0, 512, 768);
          
          nailTextures["chrome_silver"] = new THREE.CanvasTexture(canvas);
          resolve();
        });
      }

      buildUI() {
        this.buildShapePicker();
        this.buildDesignPicker();
        this.updateUI();
      }

      buildShapePicker() {
        el.shapePicker.innerHTML = '';
        
        const stepIndicator = document.createElement('div');
        stepIndicator.className = 'step-indicator';
        stepIndicator.textContent = this.t('step1');
        el.shapePicker.appendChild(stepIndicator);
        
        NAIL_SHAPES.forEach(shape => {
          const button = document.createElement('div');
          button.className = `shape-btn ${shape.id === state.currentShape ? 'selected' : ''}`;
          button.textContent = shape.name[state.currentLang];
          button.onclick = () => {
            state.currentShape = shape.id;
            document.querySelectorAll('.shape-btn').forEach(btn => {
              btn.classList.remove('selected');
            });
            button.classList.add('selected');
            
            // Update shader uniforms for selected shape
            const shapeConfig = NAIL_SHAPES.find(s => s.id === shape.id);
            FINGER_KEYS.forEach(finger => {
              const nail = nails[finger];
              if (nail && nail.material && nail.material.uniforms) {
                nail.material.uniforms.curvature.value = shapeConfig.curvature;
                nail.material.uniforms.nailLength.value = shapeConfig.length;
              }
            });
            
            this.showStatus(this.t('shapeChanged') + shape.name[state.currentLang]);
            audio.play(audio.click);
            
            this.updateDesignPreviews();
          };
          el.shapePicker.appendChild(button);
        });
      }

      buildDesignPicker() {
        el.designPicker.innerHTML = '';
        
        const stepIndicator = document.createElement('div');
        stepIndicator.className = 'step-indicator';
        stepIndicator.textContent = this.t('step2');
        el.designPicker.appendChild(stepIndicator);
        
        const designs = [
          { id: "luxury_gold", name: { en: "Luxury Gold", uk: "–†–æ–∑–∫—ñ—à–Ω–µ –∑–æ–ª–æ—Ç–æ" }, color: "linear-gradient(135deg, #ffd700, #b8941f)" },
          { id: "classic_red", name: { en: "Classic Red", uk: "–ö–ª–∞—Å–∏—á–Ω–∏–π —á–µ—Ä–≤–æ–Ω–∏–π" }, color: "linear-gradient(135deg, #DC143C, #8B0000)" },
          { id: "french_manicure", name: { en: "French", uk: "–§—Ä–µ–Ω—á" }, color: "linear-gradient(135deg, #FFF8F0, #FFE8CC)" },
          { id: "glitter_pink", name: { en: "Glitter Pink", uk: "–†–æ–∂–µ–≤–∏–π –≥–ª—ñ—Ç—Ç–µ—Ä" }, color: "linear-gradient(135deg, #ffb6e1, #ff66b2)" },
          { id: "marble", name: { en: "Marble", uk: "–ú–∞—Ä–º—É—Ä" }, color: "linear-gradient(135deg, #F8F8FF, #E0E0E0)" },
          { id: "ombre", name: { en: "Ombre", uk: "–û–º–±—Ä–µ" }, color: "linear-gradient(135deg, #FF69B4, #DC143C)" },
          { id: "gel_nude", name: { en: "Gel Nude", uk: "–ì–µ–ª—å–æ–≤–∏–π –Ω—é–¥" }, color: "linear-gradient(135deg, #FFF8F0, #E8D5C4)" },
          { id: "chrome_silver", name: { en: "Chrome Silver", uk: "–•—Ä–æ–º —Å—Ä—ñ–±–ª–æ" }, color: "linear-gradient(135deg, #F8F8FF, #C0C0C0)" }
        ];

        designs.forEach(design => {
          const button = document.createElement('div');
          button.className = `design-btn ${design.id === state.currentDesign ? 'selected' : ''}`;
          button.dataset.design = design.id;
          
          const preview = document.createElement('div');
          preview.className = 'nail-preview';
          preview.style.background = design.color;
          
          button.appendChild(preview);
          
          button.onclick = () => {
            state.currentDesign = design.id;
            document.querySelectorAll('.design-btn').forEach(btn => {
              btn.classList.remove('selected');
            });
            button.classList.add('selected');
            this.showStatus(`${design.name[state.currentLang]}`);
            this.triggerConfetti();
            audio.play(audio.click);
          };
          
          el.designPicker.appendChild(button);
        });
      }

      updateDesignPreviews() {
        // Update custom design previews with current shape
        document.querySelectorAll('.design-btn').forEach(btn => {
          const designId = btn.dataset.design;
          if (designId && designId.startsWith('custom_')) {
            // In a real app, you'd regenerate the preview here
          }
        });
      }

      updateUI() {
        document.title = this.t('title');
        el.loading.querySelector('div').textContent = this.t('title');
        el.loading.querySelector('p').textContent = this.t('cameraPrompt');
        el.handIndicator.querySelector('span:last-child').textContent = this.t('handNotDetected');
        el.uploadModal.querySelector('h3').textContent = this.t('uploadTitle');
        el.uploadModal.querySelector('p').textContent = this.t('uploadHint');
        el.saveDesign.textContent = this.t('save');
        el.closeModal.textContent = this.t('cancel');
        el.langBtn.textContent = state.currentLang === 'en' ? 'UK' : 'EN'; // –¢–µ–ø–µ—Ä UK –ø–æ–∫–∞–∑—É—î—Ç—å—Å—è –∫–æ–ª–∏ –º–æ–≤–∞ –∞–Ω–≥–ª—ñ–π—Å—å–∫–∞
        
        // Update platform info
        const platformInfo = document.getElementById('platformInfo');
        if (platformInfo) {
          platformInfo.textContent = this.t(`platform${state.platform.charAt(0).toUpperCase() + state.platform.slice(1)}`);
        }
        
        // Update step indicators
        const shapeStep = el.shapePicker.querySelector('.step-indicator');
        const designStep = el.designPicker.querySelector('.step-indicator');
        if (shapeStep) shapeStep.textContent = this.t('step1');
        if (designStep) designStep.textContent = this.t('step2');
        
        // Update shape picker labels
        document.querySelectorAll('.shape-btn').forEach((btn, index) => {
          if (NAIL_SHAPES[index]) {
            btn.textContent = NAIL_SHAPES[index].name[state.currentLang];
          }
        });
      }

      startRenderLoop() {
        let lastTime = 0;
        const fpsInterval = 1000 / CONFIG.PERFORMANCE.MAX_FPS;
        
        const renderLoop = (currentTime) => {
          requestAnimationFrame(renderLoop);
          
          const delta = currentTime - lastTime;
          if (delta < fpsInterval) return;
          
          lastTime = currentTime - (delta % fpsInterval);
          
          this.detectHands();
          this.renderAR();
          this.updateConfetti();
        };
        
        renderLoop();
      }

      pauseRendering() {
        // Reduce frame rate when app is in background
        CONFIG.PERFORMANCE.MAX_FPS = 10;
      }

      resumeRendering() {
        // Restore normal frame rate
        CONFIG.PERFORMANCE.MAX_FPS = 60;
      }

      detectHands() {
        if (!handLandmarker || el.video.readyState < 2) return;
        
        try {
          const results = handLandmarker.detectForVideo(el.video, performance.now());
          
          if (results.landmarks && results.landmarks.length > 0) {
            state.handNotDetectedCount = 0;
            el.handIndicator.classList.remove('show');
            
            const landmarks = results.landmarks[0];
            state.isLeftHand = results.handednesses[0][0].displayName === "Left";
            state.lastLandmarks = this.smoothLandmarks(landmarks);
            this.updateHandSize(landmarks);
          } else {
            if (++state.handNotDetectedCount > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
              el.handIndicator.classList.add('show');
              this.hideAllNails();
            }
          }
        } catch (error) {
          console.error('Hand detection error:', error);
        }
      }

      smoothLandmarks(newLandmarks) {
        if (!state.smoothedLandmarks) {
          state.smoothedLandmarks = newLandmarks.map(point => ({...point}));
          return state.smoothedLandmarks;
        }
        
        for (let i = 0; i < newLandmarks.length; i++) {
          state.smoothedLandmarks[i].x = this.linearInterpolation(
            state.smoothedLandmarks[i].x, newLandmarks[i].x, CONFIG.SMOOTHING_FACTOR
          );
          state.smoothedLandmarks[i].y = this.linearInterpolation(
            state.smoothedLandmarks[i].y, newLandmarks[i].y, CONFIG.SMOOTHING_FACTOR
          );
        }
        
        return state.smoothedLandmarks;
      }

      linearInterpolation(start, end, factor) {
        return start * (1 - factor) + end * factor;
      }

      updateHandSize(landmarks) {
        const wristDistance = Math.hypot(
          (landmarks[0].x - landmarks[1].x) * window.innerWidth,
          (landmarks[0].y - landmarks[1].y) * window.innerHeight
        );
        
        let scale = wristDistance / CONFIG.WRIST_DISTANCE_REF * CONFIG.SCALE_SENSITIVITY;
        scale = Math.max(0.6, Math.min(2.0, scale));
        state.currentHandSize = scale;
      }

      renderAR() {
        if (!state.lastLandmarks) return;
        
        const flipFactor = state.isLeftHand ? -1 : 1;
        const currentTime = performance.now() * 0.001;
        
        FINGER_KEYS.forEach((fingerKey, index) => {
          const nail = nails[fingerKey];
          
          if (!state.isApplyAll && index !== state.selectedFingerIndex) {
            nail.visible = false;
            return;
          }
          
          this.updateNailPosition(fingerKey, flipFactor);
          nail.visible = true;
          
          if (nailTextures[state.currentDesign]) {
            const shapeConfig = NAIL_SHAPES.find(s => s.id === state.currentShape);
            
            nail.material.uniforms.map.value = nailTextures[state.currentDesign];
            nail.material.uniforms.normalMap.value = realisticRenderer.normalMaps[state.currentShape];
            nail.material.uniforms.time.value = currentTime;
            nail.material.uniforms.shine.value = 1.0;
            nail.material.uniforms.curvature.value = shapeConfig.curvature;
            nail.material.uniforms.nailLength.value = shapeConfig.length;
            
            // Dynamic lighting based on hand position
            const lightX = Math.sin(currentTime * 0.5) * 5;
            const lightY = Math.cos(currentTime * 0.3) * 5;
            nail.material.uniforms.lightPosition.value.set(lightX, lightY, 10);
          }
        });
        
        renderer.render(scene, camera);
      }

      updateNailPosition(fingerKey, flipFactor) {
        const landmarks = state.lastLandmarks;
        const { tip, pip } = FINGER_INDICES[fingerKey];
        const tipLandmark = landmarks[tip];
        const pipLandmark = landmarks[pip];
        const offset = CONFIG.NAIL_OFFSETS[fingerKey];
        
        const rect = el.canvas.getBoundingClientRect();
        const x = (tipLandmark.x + offset.x * flipFactor) * rect.width;
        const y = (1 - (tipLandmark.y + offset.y)) * rect.height;
        
        const fingerLength = Math.hypot(
          (tipLandmark.x - pipLandmark.x) * rect.width,
          (tipLandmark.y - pipLandmark.y) * rect.height
        );
        
        let size = fingerLength * CONFIG.NAIL_SCALE_FACTORS[fingerKey] * state.currentHandSize;
        size = Math.max(CONFIG.MIN_SIZE, Math.min(CONFIG.MAX_SIZE, size));
        
        const angle = Math.atan2(
          tipLandmark.y - pipLandmark.y,
          (tipLandmark.x - pipLandmark.x) * flipFactor
        );
        
        const nail = nails[fingerKey];
        nail.position.set(x - rect.width / 2, y - rect.height / 2, 0);
        nail.scale.set(size, size, 1);
        nail.rotation.z = angle;
      }

      handleCanvasClick(event) {
        if (state.isApplyAll || !state.lastLandmarks) return;
        
        const rect = el.canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        
        let minDistance = Infinity;
        let selectedIndex = -1;
        
        FINGER_KEYS.forEach((fingerKey, index) => {
          const tipIndex = FINGER_INDICES[fingerKey].tip;
          const tipLandmark = state.lastLandmarks[tipIndex];
          const screenX = tipLandmark.x * rect.width;
          const screenY = tipLandmark.y * rect.height;
          
          const distance = Math.hypot(clickX - screenX, clickY - screenY);
          
          if (distance < minDistance && distance < rect.width * 0.1) {
            minDistance = distance;
            selectedIndex = index;
          }
        });
        
        if (selectedIndex !== -1) {
          state.selectedFingerIndex = selectedIndex;
          const fingerNames = {
            en: ['Thumb', 'Index', 'Middle', 'Ring', 'Pinky'],
            uk: ['–í–µ–ª–∏–∫–∏–π', '–í–∫–∞–∑—ñ–≤–Ω–∏–π', '–°–µ—Ä–µ–¥–Ω—ñ–π', '–ë–µ–∑—ñ–º–µ–Ω–Ω–∏–π', '–ú—ñ–∑–∏–Ω–µ—Ü—å']
          };
          this.showStatus(`Selected: ${fingerNames[state.currentLang][selectedIndex]}`);
          audio.play(audio.click);
        }
      }

      hideAllNails() {
        FINGER_KEYS.forEach(fingerKey => {
          nails[fingerKey].visible = false;
        });
        renderer.render(scene, camera);
      }

      takeScreenshot() {
        try {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = el.canvas.width;
          tempCanvas.height = el.canvas.height;
          const tempCtx = tempCanvas.getContext('2d');
          
          // Draw video background
          tempCtx.drawImage(el.video, 0, 0, tempCanvas.width, tempCanvas.height);
          
          // Draw AR overlay
          tempCtx.drawImage(el.canvas, 0, 0);
          
          tempCanvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.download = `elite-nail-${new Date().getTime()}.png`;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showStatus(this.t('screenshotSaved'));
            this.triggerConfetti();
            audio.play(audio.success);
          }, 'image/png', 0.95);
          
        } catch (error) {
          console.error('Screenshot failed:', error);
          this.showStatus('Screenshot error');
        }
      }

      handleResize() {
        if (!camera || !renderer) return;
        
        const rect = el.canvas.getBoundingClientRect();
        
        if (camera.isPerspectiveCamera) {
          camera.aspect = rect.width / rect.height;
          camera.updateProjectionMatrix();
        }
        
        renderer.setSize(rect.width, rect.height);
        
        // Adjust pixel ratio for performance
        const pixelRatio = state.platform === 'ios' ? 
          Math.min(window.devicePixelRatio, 2) : 
          Math.min(window.devicePixelRatio, 1.5);
        renderer.setPixelRatio(pixelRatio);
        
        el.confettiCanvas.width = window.innerWidth;
        el.confettiCanvas.height = window.innerHeight;
      }

      hideLoading() {
        el.loading.style.display = 'none';
        el.video.style.display = 'block';
        el.canvas.style.display = 'block';
        el.confettiCanvas.width = window.innerWidth;
        el.confettiCanvas.height = window.innerHeight;
      }

      showStatus(message, duration = 3000) {
        el.statusMessage.textContent = message;
        el.statusMessage.classList.add('show');
        
        setTimeout(() => {
          el.statusMessage.classList.remove('show');
        }, duration);
      }

      showSuccessMessage(message) {
        const successMsg = document.createElement('div');
        successMsg.textContent = message;
        successMsg.style.cssText = `
          position: fixed;
          top: 120px;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(135deg, #d4af37, #b8941f);
          color: #1c1c1e;
          padding: 16px 28px;
          border-radius: 20px;
          font-weight: 700;
          z-index: 1000;
          animation: fadeOut 3s forwards;
          box-shadow: 0 8px 32px rgba(212, 175, 55, 0.4);
        `;
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 3000);
      }

      showError(message) {
        el.loading.innerHTML = `
          <div style="color:#d4af37; font-size:32px; margin-bottom:20px;">‚ö†Ô∏è</div>
          <div style="color:#d4af37; font-size:22px; margin-bottom:20px; font-weight:700">Elite Nail AR Studio</div>
          <p style="color:#aaa; font-size:17px; line-height:1.5; max-width:320px; margin-bottom:25px;">${message}</p>
          <button onclick="location.reload()" style="padding:14px 28px; background:#d4af37; color:#1c1c1e; border:none; border-radius:20px; font-weight:600; cursor:pointer; font-size:16px;">Try Again</button>
        `;
      }
    }

    // Confetti Particle Class
    class ConfettiParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = Math.random() * -12 - 8;
        this.size = Math.random() * 8 + 4;
        this.color = ['#d4af37', '#b8941f', '#ffd700', '#fff', '#ff6b6b'][Math.floor(Math.random() * 5)];
        this.life = 1.0;
        this.gravity = 0.4;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
      }

      update() {
        this.vy += this.gravity;
        this.vx *= 0.99;
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.life -= 0.008;
      }

      draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
      }
    }

    // Add fadeOut animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes fadeOut {
        0% { opacity: 1; transform: translateX(-50%) translateY(0); }
        70% { opacity: 1; transform: translateX(-50%) translateY(0); }
        100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
      }
      
      .platform-ios {
        /* iOS specific optimizations */
      }
      
      .platform-android {
        /* Android specific optimizations */
      }
      
      .platform-desktop {
        /* Desktop specific enhancements */
      }
    `;
    document.head.appendChild(style);

    // Initialize application
    window.addEventListener('DOMContentLoaded', () => {
      detectPlatform();
      new EliteNailARStudio().init();
    });

    // Add screenshot functionality to right-click (desktop)
    document.addEventListener('contextmenu', (e) => {
      if (state.platform === 'desktop') {
        e.preventDefault();
        new EliteNailARStudio().takeScreenshot();
      }
    });

    // Handle PWA installation
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      
      // Show install button (you can add this to your UI)
      setTimeout(() => {
        if (deferredPrompt && confirm('Would you like to install the app on your device?')) {
          deferredPrompt.prompt();
          deferredPrompt.userChoice.then((choiceResult) => {
            deferredPrompt = null;
          });
        }
      }, 3000);
    });
  </script>
</body>
</html>
